If you're coming from a Relational SQL database background, modeling your data to get the most out of DynamoDB requires a little shift in thinking. In this video, I'm going to tell you how to spread your data across partitions, and I'm going to explain what we mean by a cold partition or a hot partition, and why you'll get so much benefit out of understanding this. Let's look at a traditional relational database schema for capturing AtBats in a baseball game. Remember, the baseball game has teams, players, games, and every time a batter comes to the plate, that's considered an AtBat. As you can see, we have all the elements represented here to store a log of AtBats for a professional baseball game. Now you might be tempted to create four tables in DynamoDB to represent the same data, but that's not how DynamoDB works. Ideally, you should have one table for your entire application, and explain why that's going to help you, you need to understand how DynamoDB gets its performance benefit. Every item in DynamoDB requires at least one attribute, the partition key. When you provide your item and partition key, DynamoDB hashes your key and uses that hash value as the memory address for your data. Imagine if the blocks below are different memory address spaces. I'm using Team ID as my partition. Watch what happens when I put my data into the table. The key is hashed and a memory address is assigned to that value. When I fetch the data, the same thing happens. Remember, DynamoDB is basically a key store that's highly efficient at putting and retrieving data by a given key. So selecting our partition key is the first task in data modeling. To get that single digit millisecond performance we're after, we have to try and avoid one partition becoming too hot, and to demonstrate what I mean by a hot partition, let's look at a bad example. A typical bad partition key for a table would be the date, and here's why. This has an impact on performance because there are so many resources that can access that same address space at once. This is called a hot key and it's bad and you want to avoid it. Some other examples of bad partition keys would be Order IDs and shipping numbers. Dates, we've already explained, because once they're in the past, those partitions won't get used very much. If you're using a counter for order numbers, those original keys are going to get cold real fast and never accessed again and all the activity is going to happen on a small group of partition keys. What we're after is that your partition key should be based on something regularly accessed and spread across all nodes. We want requests spread evenly, so let's go back to our baseball example, and see how our partition keys' going to help do this. There are 30 teams in major league baseball, each participating in a game every week. If I'm recording stats about all of them, wouldn't it make sense to use a partition key based on the Team ID and not the date? Let's look at our model again. Now if we store our data based on Team ID, I should get an even distribution across all partitions, which is what we want.